#include "microcin.h"

using namespace std;

void print_microcin_config (const microcin_config& mc) {
    cout << "____________________________________________________________________" << endl;
    cout << "url is also dumped to .dec file" << endl;
    cout << "________________________ spoolsv.dll microcin_config ________________________" << endl;
    cout << "url: ";
    print_storage_ascii(mc.url);
    cout << "sleep time: " << mc.time << endl;
    cout << "version: ";
    print_storage_ascii(mc.version);
    cout << "target id: ";
    print_storage_ascii(mc.target_id);
}

void print_microcin_stegano (const microcin_stegano& ms) {
    cout << "________________________ bmp stegano decrypted ________________________" << endl;
    cout << "xor byte: " << hex << int(ms.xor_byte) << endl;
    cout << "dropped mz len: " << ms.len << endl;
    cout << "domain len: " << hex << ms.domain_len << endl;
    cout << "domain: ";
    print_storage_ascii(ms.domain_dec);
    cout << endl;
}

// config related - decrypt config and other 4-bytes length
uint32_t decrypt_len(const storage_p enc, const uint8_t key) {
    uint8_t a = enc->at(key & 3) ^4;
    enc->at(0) ^= key;
    enc->at(1) ^= 4;
    enc->at(2) ^= key ^ 4;
    enc->at(3) ^= a;
    enc->at(key & 3) = a;
    return storage_to_dword(enc);
}

// TODO check if decryption is refactorable
// config related - decrypt long content like url, target_id
void decrypt_content(const storage_p enc, const uint8_t key) {
    storage xor_key(6);
    uint8_t a;
    uint32_t l = enc->size();
    // key scheduling
    xor_key.at(1) = (uint8_t)l;
    xor_key.at(0) = key;
    xor_key.at(2) = key ^ (uint8_t)l;
    a = enc->at(key % l);
    xor_key.at(3) = (uint8_t)l ^ a;
    xor_key.at(5) = (uint8_t)l ^ xor_key.at(3);
    xor_key.at(4) = key ^ xor_key.at(3);
    // decryption
    dexor(enc, make_shared<storage>(xor_key), 6);
    enc->at(key % l) = xor_key.at(3);
}

void read_bfh(file& m_file, microcin_stegano& ms) {
    ms.bfh.bfType = m_file.get_word();
    ms.bfh.bfSize = m_file.get_dword();
    ms.bfh.bfReserved1 = m_file.get_word();
    ms.bfh.bfReserved2 = m_file.get_word();
    ms.bfh.bfOffBits = m_file.get_dword();
}

void read_bih(file& m_file, microcin_stegano& ms) {
    ms.bih.biSize = m_file.get_dword();
    ms.bih.biWidth = m_file.get_dword();
    ms.bih.biHeight = m_file.get_dword();
    ms.bih.biPlanes = m_file.get_word();
    ms.bih.biBitCount = m_file.get_word();
    ms.bih.biCompression = m_file.get_dword();
    ms.bih.biSizeImage = m_file.get_dword();
    ms.bih.biXPelsPerMeter = m_file.get_dword();
    ms.bih.biYPelsPerMeter = m_file.get_dword();
    ms.bih.biClrUsed = m_file.get_dword();
    ms.bih.biClrImportant = m_file.get_dword();
}

void parse_microcin_stegano(const string& fn) {
    microcin_stegano ms;
    file m_file(fn);

    // read bmp header
    read_bfh(m_file, ms);
    read_bih(m_file, ms);

    // decrypt MZ len and content, dump
    ms.xor_byte = storage_to_byte(hex_to_bin(m_file.get_bytes(2)));
    ms.len = decrypt_len(hex_to_bin(m_file.get_bytes(8)), ms.xor_byte);
    ms.mz_dec = hex_to_bin(m_file.get_bytes(2 * ms.len));
    decrypt_content(ms.mz_dec, ms.xor_byte);
    m_file.dump_to_file(fn + ".mz.dec", ms.mz_dec);
    cout << "network module dumped into " << fn << ".mz.dec" << endl;

    // get domain len and content, dump
    ms.domain_len = decrypt_len(hex_to_bin(m_file.get_bytes(8)), ms.xor_byte);
    ms.domain_dec = hex_to_bin(m_file.get_bytes(2 * ms.domain_len));
    decrypt_content(ms.domain_dec, ms.xor_byte);
//    b.domain_dec = get_content_combine_bytes(fs, b.domain_dec, b.domain_len, b.xor_byte);
    m_file.dump_to_file(fn + ".dom.dec", ms.domain_dec);
    cout << "domains dumped into " << fn << ".dom.dec" << endl;

    print_microcin_stegano(ms);
}

void parse_microcin_config (const string& fn) {
    microcin_config m_config;
    file m_file(fn);

    // get microcin_config len from file end and set to microcin_config start
    m_file.set_offset(-4, 1);
    m_config.len = m_file.get_dword();

    if (m_config.len > 0x1000) {
        m_file.set_offset(-0x18, 1);
        cout << "__________________________ canary present __________________________" << endl;
        cout << "due to canary presence skipped 0x14 bytes" <<  endl;
        m_config.len = m_file.get_dword();
    }
    m_file.set_offset(-4 - m_config.len, 2);

    // get xor byte and url len
    m_config.xor_byte = m_file.get_byte();
    m_config.url_len = decrypt_len(m_file.get_bytes(4), m_config.xor_byte);

    // decrypt url
    m_config.url = m_file.get_bytes(m_config.url_len);
    decrypt_content(m_config.url, m_config.xor_byte);

    // decrypt sleep time
    m_config.time = m_file.get_word();
    m_config.time ^= (m_config.xor_byte << 8) ^ 0x02;

    // decrypt version len
    m_config.version_len = decrypt_len(m_file.get_bytes(4), m_config.xor_byte);

    // decrypt version name
    m_config.version = m_file.get_bytes(m_config.version_len);
    decrypt_content(m_config.version, m_config.xor_byte);

    // decrypt target_id len
    m_config.target_id_len = decrypt_len(m_file.get_bytes(4), m_config.xor_byte);

    // decrypt target_id
    m_config.target_id = m_file.get_bytes(m_config.target_id_len);
    decrypt_content(m_config.target_id, m_config.xor_byte);

    m_file.dump_to_file(fn + ".dec", m_config.url);
    print_microcin_config(m_config);
}