#include "microcin.h"

using namespace std;

void print_microcin_config (microcin_config& c) {
    cout << "____________________________________________________________________" << endl;
    cout << "url is also dumped to .dec file" << endl;
    cout << "________________________ spoolsv.dll microcin_config ________________________" << endl;
    cout << "url: ";
    print_storage_ascii(c.url);
    cout << "sleep time: " << c.time << endl;
    cout << "version: ";
    print_storage_ascii(c.version);
    cout << "target id: ";
    print_storage_ascii(c.target_id);
}

uint32_t decrypt_len(const storage_p it, const int8_t key) {
    uint8_t a = it->at(key & 3) ^4;
    it->at(0) ^= key;
    it->at(1) ^= 4;
    it->at(2) ^= key ^ 4;
    it->at(3) ^= a;
    it->at(key & 3) = a;
    return storage_to_dword(it);
}

// TODO check if decryption is refactorable
void decrypt_content(const storage_p enc, const uint8_t key) {
    storage xor_key(6);
    uint8_t a;
    uint8_t l = enc->size();
    // key scheduling
    xor_key.at(1) = l;
    xor_key.at(0) = key;
    xor_key.at(2) = key ^ l;
    a = enc->at(key % l);
    xor_key.at(3) = l ^ a;
    xor_key.at(5) = l ^ xor_key.at(3);
    xor_key.at(4) = key ^ xor_key.at(3);
    // decryption
    dexor(enc, make_shared<storage>(xor_key), 6);
    enc->at(key % l) = xor_key.at(3);
}

void parse_microcin_config (const string& fn) {
    microcin_config m_config;
    file m_file(fn);

    // get microcin_config len from file end and set to microcin_config start
    m_file.set_offset(-4, 1);
    m_config.len = m_file.get_dword();

    if (m_config.len > 0x1000) {
        m_file.set_offset(-0x18, 1);
        cout << "__________________________ canary present __________________________" << endl;
        cout << "due to canary presence skipped 0x14 bytes" <<  endl;
        m_config.len = m_file.get_dword();
    }
    m_file.set_offset(-4 - m_config.len, 2);

    // get xor byte and url len
    m_config.xor_byte = m_file.get_byte();
    m_config.url_len = decrypt_len(m_file.get_bytes(4), m_config.xor_byte);

    // decrypt url
    m_config.url = m_file.get_bytes(m_config.url_len);
    decrypt_content(m_config.url, m_config.xor_byte);

    // decrypt sleep time
    m_config.time = m_file.get_word();
    m_config.time ^= (m_config.xor_byte << 8) ^ 0x02;

    // decrypt version len
    m_config.version_len = decrypt_len(m_file.get_bytes(4), m_config.xor_byte);

    // decrypt version name
    m_config.version = m_file.get_bytes(m_config.version_len);
    decrypt_content(m_config.version, m_config.xor_byte);

    // decrypt target_id len
    m_config.target_id_len = decrypt_len(m_file.get_bytes(4), m_config.xor_byte);

    // decrypt target_id
    m_config.target_id = m_file.get_bytes(m_config.target_id_len);
    decrypt_content(m_config.target_id, m_config.xor_byte);

    m_file.dump_to_file(fn + ".dec", m_config.url);
    print_microcin_config(m_config);
}